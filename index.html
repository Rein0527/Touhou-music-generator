<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Touhou Player — M1+M2 MVP (Rev B)</title>
  <style>
    :root {
      --bg-fade-ms: 850;          /* 背景淡入時間 */
      --accent: #e8458b;
      --accent-2: #7aa8ff;
      --text: #edeef2;
      --muted: #9aa3b2;
      --panel: rgba(16,18,24,0.55);
      --border: rgba(148,163,184,0.16);
    }
    html, body { height: 100%; margin: 0; background: #0b0d12; color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "PingFang TC", "Microsoft JhengHei", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .app { position: relative; min-height: 100%; overflow: hidden; }

    /* 背景層 */
    .bg, .bg-next { position: absolute; inset: 0; background-position: center; background-size: cover; filter: blur(8px) saturate(1.05) brightness(0.74); transform: scale(1.03); transition: opacity calc(var(--bg-fade-ms) * 1ms) ease; }
    .bg { opacity: 1; }
    .bg-next { opacity: 0; }
    .bg-dim { position: absolute; inset: 0; background: radial-gradient(ellipse at center, rgba(0,0,0,0.2), rgba(0,0,0,0.62) 58%, rgba(0,0,0,0.82)); pointer-events: none; }

    /* 舞台（上） */
    .stage { position: relative; z-index: 10; display: grid; place-items: center; min-height: 72vh; padding-top: 5vh; }
    canvas { width: min(78vmin, 1040px); height: min(78vmin, 1040px); aspect-ratio: 1 / 1; touch-action: none; }

    /* 控制列（下） */
    .bar { position: fixed; left: 0; right: 0; bottom: 0; z-index: 20; display: grid; grid-template-columns: auto 1fr auto auto; gap: 14px; align-items: center; padding: 12px clamp(14px, 3vw, 24px); backdrop-filter: blur(8px); background: var(--panel); border-top: 1px solid var(--border); }
    .meta { min-width: 200px; overflow: hidden; }
    .title { font-weight: 700; letter-spacing: .2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .artist { color: var(--muted); font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .controls { display: inline-flex; gap: 10px; }
    .btn { appearance: none; border: 1px solid rgba(148,163,184,0.22); color: var(--text); background: linear-gradient(180deg, rgba(33,41,54,.65), rgba(18,23,33,.65)); padding: 10px 12px; border-radius: 12px; font-size: 14px; cursor: pointer; user-select: none; }
    .btn:hover { border-color: rgba(255,255,255,0.35); }
    .btn:active { transform: translateY(1px); }
    .btn.icon { width: 44px; height: 44px; display: grid; place-items: center; font-size: 18px; }
    .vol { display: inline-flex; align-items: center; gap: 8px; font-size: 12px; color: var(--muted); }
    .vol input { width: 140px; }
    .filepick { font-size: 12px; opacity: .85; }

    /* 拖放提示 */
    .dropmask { position: fixed; inset: 0; background: rgba(18,23,33,0.75); color: var(--text); display: none; place-items: center; z-index: 40; border: 2px dashed rgba(255,255,255,0.35); font-size: clamp(16px, 3vw, 24px); letter-spacing: 1px; }
    .dropmask.on { display: grid; }

    /* 輔助提示 */
    .hint { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); font-size: 12px; color: var(--muted); opacity: .88; letter-spacing: .2px; z-index: 20; background: var(--panel); border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="bg" id="bg"></div>
    <div class="bg-next" id="bgNext"></div>
    <div class="bg-dim"></div>

    <div class="hint">Space 播放/暫停 · A/D 上/下一首 · ←/→ 跳 5 秒（Ctrl=15 秒） · 舞台「水平」點擊/拖曳快轉 · 拖放音檔加入播放</div>

    <div class="stage" id="stage">
      <canvas id="viz" width="1200" height="1200" aria-label="視覺化畫布" role="img"></canvas>
    </div>

    <div class="bar" role="group" aria-label="播放器控制">
      <div class="controls">
        <button class="btn icon" id="prev" title="上一首">⟨</button>
        <button class="btn icon" id="play" title="播放/暫停">▶</button>
        <button class="btn icon" id="next" title="下一首">⟩</button>
      </div>

      <div class="meta">
        <div class="title" id="metaTitle">—</div>
        <div class="artist" id="metaArtist">—</div>
      </div>

      <label class="btn filepick" for="fileInput">＋ 匯入本地音樂</label>
      <input id="fileInput" type="file" accept="audio/*" multiple hidden />

      <div class="vol">音量 <input id="volume" type="range" min="0" max="1" step="0.01" value="1" /></div>
    </div>

    <div class="dropmask" id="dropmask">拖放音檔到這裡以加入播放</div>
  </div>

  <audio id="audio" crossorigin="anonymous"></audio>

  <script>
  // ===== 狀態 =====
  const STATE = {
    tracks: [],
    localTracks: [],
    queue: [], qIndex: 0,
    playing: false,
    imagesByTag: {}, currentImages: [], bgIdx: 0, bgTimer: null,
    bgIntervalMs: 15000,
  };

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);
  const elAudio = $("audio");
  const elCanvas = $("viz");
  const ctx = elCanvas.getContext("2d");
  const elPrev = $("prev"), elPlay = $("play"), elNext = $("next");
  const elTitle = $("metaTitle"), elArtist = $("metaArtist");
  const elFile = $("fileInput"), elVol = $("volume");
  const dropmask = $("dropmask");
  const bg = $("bg"), bgNext = $("bgNext");

  // ===== 讀取清單 =====
  async function loadJSON(path) {
    try {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) throw new Error(res.status + " " + res.statusText);
      return await res.json();
    } catch (e) { console.warn("loadJSON fail", path, e); return null; }
  }
  async function initData() {
    const [tracks, images] = await Promise.all([
      loadJSON("data/tracks.json"),
      loadJSON("data/images.json"),
    ]);
    STATE.tracks = Array.isArray(tracks) ? tracks : [];
    STATE.imagesByTag = images && typeof images === 'object' ? images : {};
    if (STATE.tracks.length === 0) toast("找不到 tracks.json，請先在 /data 準備清單或匯入本地音樂");
    rebuildQueue(); updateMeta(); refreshBackgroundPool();
  }

  function rebuildQueue() {
    const count = STATE.tracks.length + STATE.localTracks.length;
    STATE.queue = [...Array(count).keys()];
    for (let i = STATE.queue.length - 1; i > 0; i--) { const j = Math.floor(Math.random()* (i+1)); [STATE.queue[i], STATE.queue[j]] = [STATE.queue[j], STATE.queue[i]]; }
    STATE.qIndex = 0;
  }
  function resolveTrackByQueueIndex(qi) {
    const gi = STATE.queue[qi]; const base = STATE.tracks.length;
    if (gi < base) return { ...STATE.tracks[gi], isLocal:false };
    return { ...STATE.localTracks[gi - base], isLocal:true };
  }
  function currentTrack(){ return resolveTrackByQueueIndex(STATE.qIndex); }

  // ===== 音訊與視覺化 =====
  let audioCtx, analyser, sourceNode, rafId = 0;
  function ensureAudioGraph(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.8;
      sourceNode = audioCtx.createMediaElementSource(elAudio);
      sourceNode.connect(analyser); analyser.connect(audioCtx.destination);
    }
  }

  function playCurrent(){
    const t = currentTrack(); if (!t) return;
    ensureAudioGraph();
    elAudio.src = t.file;
    elAudio.play().then(()=>{ STATE.playing=true; elPlay.textContent = "⏸"; updateMeta(); refreshBackgroundPool(); startViz(); })
      .catch(err=>{ console.warn("audio play error", err); toast("無法播放："+(t.title||t.file)); next(); });
  }
  function pause(){ elAudio.pause(); STATE.playing=false; elPlay.textContent = "▶"; }
  function togglePlay(){ (STATE.playing? pause: playCurrent)(); }
  function prev(){ STATE.qIndex = (STATE.qIndex - 1 + STATE.queue.length) % STATE.queue.length; playCurrent(); }
  function next(){ STATE.qIndex = (STATE.qIndex + 1) % STATE.queue.length; playCurrent(); }

  // ===== 視覺化繪製 =====
  function startViz(){
    cancelAnimationFrame(rafId);
    const W=elCanvas.width, H=elCanvas.height, cx=W/2, cy=H/2;
    const radius = Math.min(W,H)*0.34;
    const progressOuter = radius + 52;  // 較細
    const progressThick = 10;           // 較細
    const freqBins = 64;                // 降密度
    const data = new Uint8Array(analyser.frequencyBinCount);

    (function loop(){
      rafId = requestAnimationFrame(loop);
      if (!analyser) return;
      analyser.getByteFrequencyData(data);
      ctx.clearRect(0,0,W,H);

      // 等化器（64 柱）
      const step = Math.floor(data.length / freqBins);
      for (let i=0;i<freqBins;i++){
        const v = data[i*step] / 255;
        const bar = 24 + v * 160;
        const a = (i/freqBins) * Math.PI*2;
        const x1 = cx + Math.cos(a)*radius;
        const y1 = cy + Math.sin(a)*radius;
        const x2 = cx + Math.cos(a)*(radius+bar);
        const y2 = cy + Math.sin(a)*(radius+bar);
        ctx.strokeStyle = `rgba(255,255,255,${0.3 + v*0.55})`;
        ctx.lineWidth = 3.5;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }

      // 進度環（純顯示）
      const d = elAudio.duration||0, ct=elAudio.currentTime||0, p = d>0? ct/d: 0;
      const startAngle = -Math.PI/2, endAngle = startAngle + p*Math.PI*2;
      ctx.strokeStyle = "rgba(255,255,255,0.18)"; ctx.lineWidth = progressThick;
      ctx.beginPath(); ctx.arc(cx,cy,progressOuter,0,Math.PI*2); ctx.stroke();
      const grad = ctx.createLinearGradient(cx-progressOuter, cy-progressOuter, cx+progressOuter, cy+progressOuter);
      grad.addColorStop(0, "#ff8bd1"); grad.addColorStop(1, "#6da8ff");
      ctx.strokeStyle = grad; ctx.lineCap = "round";
      ctx.beginPath(); ctx.arc(cx,cy,progressOuter,startAngle,endAngle,false); ctx.stroke();
      const hx = cx + Math.cos(endAngle)*progressOuter; const hy = cy + Math.sin(endAngle)*progressOuter;
      ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(hx,hy,5.5,0,Math.PI*2); ctx.fill();
    })();
  }

  // ===== 水平點擊/相對拖曳快轉 =====
  let dragging=false, startX=0, startTime=0, pendingSeek=null, scrubRaf=0, lowFps=false;

  function canvasToX(e){
    const rect = elCanvas.getBoundingClientRect();
    return (e.clientX - rect.left) * (elCanvas.width / rect.width);
  }
  function width(){ const r = elCanvas.getBoundingClientRect(); return elCanvas.width; }

  function seekAbsoluteByX(x){
    const w = width(); const p = Math.min(1, Math.max(0, x / w));
    if (Number.isFinite(elAudio.duration) && elAudio.duration>0) scheduleSeek(elAudio.duration * p);
  }
  function seekRelativeByDX(dx){
    const w = width(); if (!Number.isFinite(elAudio.duration) || elAudio.duration<=0) return;
    const delta = dx / w; const t = Math.min(elAudio.duration, Math.max(0, startTime + delta * elAudio.duration));
    scheduleSeek(t);
  }
  function scheduleSeek(t){ pendingSeek = t; if (!scrubRaf) scrubRaf = requestAnimationFrame(applySeek); }
  function applySeek(){
    scrubRaf = 0;
    if (pendingSeek==null) return;
    if (typeof elAudio.fastSeek === 'function') try { elAudio.fastSeek(pendingSeek); } catch { elAudio.currentTime = pendingSeek; }
    else elAudio.currentTime = pendingSeek;
    pendingSeek = null;
  }

  elCanvas.addEventListener('pointerdown', (e)=>{
    elCanvas.setPointerCapture(e.pointerId);
    dragging = true; startX = canvasToX(e); startTime = elAudio.currentTime||0;
    // 點擊行為：立即絕對定位到 x 比例
    seekAbsoluteByX(startX);
    // 降低等化器成本（拖曳更順）
    if (!lowFps){ analyser.smoothingTimeConstant = 0.9; lowFps=true; }
  });
  elCanvas.addEventListener('pointermove', (e)=>{ if (!dragging) return; const x = canvasToX(e); seekRelativeByDX(x - startX); });
  function endDrag(e){ if (!dragging) return; dragging=false; try{ elCanvas.releasePointerCapture(e.pointerId); }catch{}
    // 恢復普通視覺化設定
    if (lowFps){ analyser.smoothingTimeConstant = 0.8; lowFps=false; }
  }
  elCanvas.addEventListener('pointerup', endDrag);
  elCanvas.addEventListener('pointercancel', endDrag);

  // ===== 背景圖片輪播 =====
  function refreshBackgroundPool(){
    const t = currentTrack();
    const tags = (t && Array.isArray(t.tags) && t.tags.length) ? t.tags : ["touhou"];
    const pool=[], seen=new Set();
    for (const tag of tags){ const imgs = STATE.imagesByTag[tag]||[]; for (const it of imgs){ if (!it||!it.url||seen.has(it.url)) continue; seen.add(it.url); pool.push(it.url);} }
    STATE.currentImages = pool; STATE.bgIdx=0; rotateBg(true);
    if (STATE.bgTimer) clearInterval(STATE.bgTimer);
    STATE.bgTimer = setInterval(()=>rotateBg(false), STATE.bgIntervalMs);
  }
  function rotateBg(initial=false){ if (!STATE.currentImages.length) return; STATE.bgIdx = (STATE.bgIdx + (initial?0:1)) % STATE.currentImages.length; const url = STATE.currentImages[STATE.bgIdx]; const img=new Image(); img.onload=()=>swapBg(url); img.src=url; }
  function swapBg(url){
    bgNext.style.backgroundImage = `url("${url}")`; bgNext.style.opacity = 1;
    setTimeout(()=>{ bg.style.backgroundImage = `url("${url}")`; bgNext.style.opacity = 0; }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bg-fade-ms')));
  }

  // ===== UI =====
  function updateMeta(){ const t=currentTrack(); elTitle.textContent = t ? (t.title || t.file.split('/').pop()) : '—'; elArtist.textContent = t ? (t.artist || (t.isLocal? '(Local)':'Unknown')) : '—'; }
  function toast(msg){ console.log(msg); }

  elPrev.addEventListener('click', prev);
  elNext.addEventListener('click', next);
  elPlay.addEventListener('click', togglePlay);
  elVol.addEventListener('input', ()=>{ elAudio.volume = parseFloat(elVol.value); });

  elAudio.addEventListener('ended', next);

  // 鍵盤
  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space'){ e.preventDefault(); togglePlay(); }
    else if (e.key==='a'||e.key==='A') prev();
    else if (e.key==='d'||e.key==='D') next();
    else if (e.key==='ArrowLeft'){ elAudio.currentTime = Math.max(0, elAudio.currentTime - (e.ctrlKey?15:5)); }
    else if (e.key==='ArrowRight'){ elAudio.currentTime = Math.min(elAudio.duration||1e9, elAudio.currentTime + (e.ctrlKey?15:5)); }
  });

  // 匯入本地檔
  elFile.addEventListener('change', ()=> handleFiles(elFile.files));
  function handleFiles(fileList){
    const arr = Array.from(fileList||[]).filter(f=>f.type.startsWith('audio/'));
    const news = arr.map(f=>({ file: URL.createObjectURL(f), title: f.name.replace(/\.[^/.]+$/, ''), artist: '(Local)', tags: ['touhou'] }));
    if (news.length){ STATE.localTracks.push(...news); rebuildQueue(); updateMeta(); toast(`已加入本地曲目 ${news.length} 首`); }
  }

  // 拖放加入
  ;['dragenter','dragover'].forEach(ev=>document.addEventListener(ev,(e)=>{ e.preventDefault(); dropmask.classList.add('on'); }));
  ;['dragleave','drop'].forEach(ev=>document.addEventListener(ev,(e)=>{ e.preventDefault(); if (ev==='drop') handleFiles(e.dataTransfer.files); dropmask.classList.remove('on'); }));

  // 啟動
  initData();
  </script>
</body>
</html>
