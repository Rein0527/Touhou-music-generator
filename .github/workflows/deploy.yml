- name: Generate data/tracks.json & images.json
  shell: bash
  run: |
    set -euo pipefail
    mkdir -p data scripts
    cat > scripts/gen.mjs << 'EOF'
    import fs from 'node:fs';
    import path from 'node:path';

    const musicRoot = path.join(process.cwd(),'music');
    const dataDir   = path.join(process.cwd(),'data');
    const exts = new Set(['.mp3','.ogg','.wav','.m4a','.flac']);

    function walk(dir){
      let out = [];
      if (!fs.existsSync(dir)) return out;
      for (const name of fs.readdirSync(dir)){
        if (name.startsWith('.')) continue;
        const p = path.join(dir, name);
        const st = fs.statSync(p);
        if (st.isDirectory()) out = out.concat(walk(p));
        else if (exts.has(path.extname(name).toLowerCase())) out.push(p);
      }
      return out;
    }

    // ---- tracks.json ----
    let relFiles = [];
    if (fs.existsSync(musicRoot)) {
      relFiles = walk(musicRoot).map(abs =>
        path.posix.join('music', path.relative(musicRoot, abs).split(path.sep).join('/'))
      );
    } else {
      console.log('⚠️  沒有 /music 目錄，tracks.json 將為空陣列');
    }

    function sanitizeTag(s){ return s.toLowerCase().replace(/[^a-z0-9_\-]/g,'').slice(0,40); }

    const tracks = relFiles.map(rel => {
      const base = path.basename(rel).replace(/\.[^.]+$/,'');
      let artist='Unknown', title=base;
      const m = base.split(' - ');
      if (m.length>=2){ artist=m[0]; title=m.slice(1).join(' - '); }
      const segs = rel.split('/').slice(1,-1); // e.g. [ 'th10' ]
      const dirTags = segs.map(sanitizeTag).filter(Boolean);
      const nameTags = base.split(/[^a-zA-Z0-9]+/).map(sanitizeTag).filter(Boolean);
      const set = new Set(['touhou', ...dirTags, ...nameTags]);
      return { file: rel, title, artist, tags: [...set].slice(0,8) };
    });

    fs.writeFileSync(path.join(dataDir,'tracks.json'), JSON.stringify(tracks, null, 2));
    console.log('✅ tracks.json 產生完成，曲目數：', tracks.length);

    // ---- images.json ----
    const tagSet = new Set(['touhou']);
    tracks.forEach(t => (t.tags||['touhou']).forEach(tag => tagSet.add(tag)));

    const images = {};
    for (const tag of tagSet) {
      try {
        const url = `https://danbooru.donmai.us/posts.json?limit=30&tags=${encodeURIComponent(tag + ' rating:safe order:rank')}`;
        const res = await fetch(url, { headers: { 'User-Agent': 'GitHubActions/1.0 (+pages)' }});
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const arr = await res.json();
        const seen = new Set(); const list = [];
        for (const p of arr) {
          const u = p.large_file_url || p.file_url;
          if (!u || p.rating !== 's') continue;
          const abs = u.startsWith('http') ? u : `https://danbooru.donmai.us${u}`;
          if (seen.has(abs)) continue;
          seen.add(abs);
          list.push({ url: abs, source: `post:${p.id}` });
        }
        images[tag] = list;
        console.log(`🖼️  ${tag}: ${list.length} 張`);
        await new Promise(r => setTimeout(r, 250)); // 輕微節流
      } catch (err) {
        console.log('⚠️  產生圖片失敗：', tag, err.message);
        images[tag] = images[tag] || [];
      }
    }
    fs.writeFileSync(path.join(dataDir,'images.json'), JSON.stringify(images, null, 2));
    console.log('✅ images.json 產生完成');
    EOF

    node scripts/gen.mjs
